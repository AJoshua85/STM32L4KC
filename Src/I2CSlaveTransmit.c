/*
 * I2CSlaveTransmit.c
 *
 *  Created on: Aug. 23, 2020
 *      Author: Avinash
 */


/**
  ******************************************************************************
  * @file    main.c
  * @author  Auto-generated by STM32CubeIDE
  * @version V1.0
  * @brief   Default main function.
  ******************************************************************************
*/

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
#include <STM32F303x8.h>
#include <STM32F303X_gpio_driver.h>
#include <STM32F303X_spi_driver.h>
#include <STM32F303X_i2c_driver.h>
#include <string.h>

/* SPI NSSS PA4 AF5
 * SPI SCK  PA5 AF5
 * SPI MISO PA6 AF5
 * SPI MOSI PA7 AF5
 * I2C1 SCL PB6 AF4
 * I2C1 SDA PB7 AF4
 * */

I2C_Handle_t I2C1Handle;
char buffer [30];
char txbuffer[]="Hello";
uint8_t cmdCode =0x00;

int num = 0;
int stp =  0;
int addr = 0;
int nack = 0;

int rx = 0;

void I2C_GPIOInits(void)
{
	GPIO_Handle_t I2CPins;
	I2CPins.pGPIOx = GPIOB;
	I2CPins.GPIO_PinConfig.GPIO_Pinmode = GPIO_MODE_ALTFN;
	I2CPins.GPIO_PinConfig.GPIO_PinAltFn = 4;
	I2CPins.GPIO_PinConfig.GPIO_PinOPType = GPIO_OP_TYPE_OD;
	I2CPins.GPIO_PinConfig.GPIO_PinPuPdCtrl = GPIO_NO_PUPD;
	I2CPins.GPIO_PinConfig.GPIO_PinSpeed = GPIO_SPD_FAST;

	//SDA
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = 6;
	GPIO_Init(&I2CPins);
	//SCL
	I2CPins.GPIO_PinConfig.GPIO_PinNumber = 7;
	GPIO_Init(&I2CPins);
}

void I2C_PinInits(void)
{

	I2C1Handle.pI2Cx = I2C1;
	I2C1Handle.I2C_Config.I2C_PRESC = 0x01;
	I2C1Handle.I2C_Config.I2C_SCLH = 0x61;
	I2C1Handle.I2C_Config.I2C_SCLL = 0x63;
	I2C1Handle.I2C_Config.I2C_SDADEL =0x01;
	I2C1Handle.I2C_Config.I2C_SCLDEL =0x01;
	I2C1Handle.I2C_Config.I2C_DeviceAddr=0x62;
	I2C_Init(&I2C1Handle);

}


int main(void)
{
	char buffer[]="This is a Test between slave and master";
	uint8_t flag = 0;
	uint8_t len = strlen(buffer);
	I2C_GPIOInits();
	I2C_PinInits();
	I2C_IRQITConfig(IRQ_NO_I2C1_EV,ENABLE);
	I2C_PeripheralControl(I2C1,ENABLE);

	while(I2C_SlaveRecieveDataIT(&I2C1Handle,&cmdCode,1)!= SUCCESS);
	for(;;)
	{
		if(cmdCode== 0x50 && I2C1Handle.TxRxState == I2C_READY)
		{
			flag++;
			while(I2C_SlaveSendDataIT(&I2C1Handle,&len,1)!=SUCCESS);
			while(I2C_SlaveRecieveDataIT(&I2C1Handle,&cmdCode,1)!= SUCCESS);

		}

		else if (cmdCode == 0x51 && I2C1Handle.TxRxState == I2C_READY)
		{
			flag++;
			while(I2C_SlaveSendDataIT(&I2C1Handle,(uint8_t*)buffer,len)!=SUCCESS);
			while(I2C_SlaveRecieveDataIT(&I2C1Handle,&cmdCode,1)!= SUCCESS);
		}

	}
}

void I2C1_EV_EXTI23_IRQHandler(void)
{

	I2CReadStatusFlag(I2C1);
	if(getI2CFlag() == ADDRMATCH)
	{
		addr++;
		addressMatchEvent(I2C1);
	}

	else if (getI2CFlag() == RXEREADY)
	{
		rx++;
		recieverBufferFullEvent(&I2C1Handle);
	}

	else if (getI2CFlag() == STOPBIT)
	{
		stp++;
		stopFlagEvent(&I2C1Handle);
	}

	else if (getI2CFlag() == NACKF)
	{
		nack++;
		nackEvent(&I2C1Handle);
	}

	else if (getI2CFlag() == TXISREADY)
	{

		transmitReadyEvent(&I2C1Handle);
	}

}
